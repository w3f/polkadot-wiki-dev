(self.webpackChunk=self.webpackChunk||[]).push([[2508],{47940:(e,n,a)=>{"use strict";a.d(n,{Z:()=>h});var t=a(74165),i=a(15861),o=a(67294),s=a(87152),c=a(34200),r=a(67425);function l(e,n,a){return d.apply(this,arguments)}function d(){return(d=(0,i.Z)((0,t.Z)().mark((function e(n,a,i){var o,r,l,d,p;return(0,t.Z)().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:o=void 0,r=void 0,e.t0=n,e.next="polkadot"===e.t0?5:"kusama"===e.t0?7:"statemine"===e.t0?9:"statemint"===e.t0?11:13;break;case 5:return o="wss://rpc.polkadot.io",e.abrupt("break",14);case 7:return o="wss://kusama-rpc.polkadot.io/",e.abrupt("break",14);case 9:return o="wss://statemine-rpc.polkadot.io/",e.abrupt("break",14);case 11:return o="wss://statemint-rpc.polkadot.io/",e.abrupt("break",14);case 13:console.log("Unknown socket url provided, no connection made.");case 14:if(void 0!==o){e.next=18;break}return e.abrupt("return");case 18:return l=new s.U(o),e.next=21,c.G.create({provider:l});case 21:d=e.sent,(p=a.split(".")).forEach((function(e){e in d&&(d=d[e])})),e.t1=p[0],e.next="consts"===e.t1?27:"query"===e.t1?29:34;break;case 27:return r=d.toString(),e.abrupt("break",35);case 29:return e.next=31,d();case 31:return r=(r=e.sent).toString(),e.abrupt("break",35);case 34:console.log("Unknown path prefix ("+p[0]+") in "+a);case 35:return e.abrupt("return",r);case 36:case"end":return e.stop()}}),e)})))).apply(this,arguments)}function p(e,n,a,t){switch(n){case"humanReadable":(0,r.HumanReadable)(e,a,t);break;case"precise":(0,r.Precise)(e,a,t);break;case"blocksToDays":(0,r.BlocksToDays)(e,t);break;case"percentage":(0,r.Percentage)(e,t);break;case"arrayLength":(0,r.ArrayLength)(e,t);break;default:return void console.log("Ignoring unknown filter type")}}const h=function(e){var n=e.network,a=e.path,s=e.defaultValue,c=e.filter,r=void 0===c?void 0:c,d=(0,o.useState)(""),h=d[0],k=d[1];return n=n.toLowerCase(),(0,o.useEffect)((function(){void 0!==r?p(s.toString(),r,n,k):k(s.toString());var e=void 0;switch(n){case"polkadot":e="wss://rpc.polkadot.io";break;case"kusama":e="wss://kusama-rpc.polkadot.io/";break;case"statemine":e="wss://statemine-rpc.polkadot.io/";break;case"statemint":e="wss://statemint-rpc.polkadot.io/";break;default:console.log("Unknown network provided, "+n)}if(void 0===e)console.log("Failed to connect to a valid websocket, applying default");else{var o=function(){var e=(0,i.Z)((0,t.Z)().mark((function e(){var i;return(0,t.Z)().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,l(n,a,k);case 2:if(void 0!==(i=e.sent)){e.next=7;break}return e.abrupt("return");case 7:void 0!==r?p(i,r,n,k):k(i);case 8:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}();try{o()}catch(c){console.log(c)}}}),[]),h}},67425:e=>{var n={polkadot:{precision:1e10,symbol:"DOT"},kusama:{precision:1e12,symbol:"KSM"},statemint:{precision:1e10,symbol:"DOT"},statemine:{precision:1e12,symbol:"KSM"}};e.exports={HumanReadable:function(e,a,t){var i=void 0;if("polkadot"===a||"statemint"===a)i=3;else{if("kusama"!==a&&"statemine"!==a)return void console.log("Unknown network type found when attempting to apply 'Human Readable' filter");i=6}e=parseFloat(e),t((e=Number.isInteger(e/n[a].precision)?e/n[a].precision+" "+n[a].symbol:(e/n[a].precision).toFixed(i)+" "+n[a].symbol).toString())},Precise:function(e,a,t){t(e=(e=parseFloat(e))/n[a].precision+" "+n[a].symbol)},BlocksToDays:function(e,n){n((e=6*e/86400).toString())},Percentage:function(e,n){n((e/=1e7).toString())},ArrayLength:function(e,n){n((e=e.split(",").length).toString())}}},90594:(e,n,a)=>{"use strict";a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>u,frontMatter:()=>c,metadata:()=>l,toc:()=>p});var t=a(87462),i=a(63366),o=(a(67294),a(3905)),s=(a(47940),["components"]),c={id:"learn-async-backing",title:"Asynchronous Backing",sidebar_label:"Asynchronous Backing",description:"A brief overview of asynchronous backing, and how it affects Polkadot's scalability.",keywords:["parachains","backing","parablock","perspective parachains","unincluded segments"],slug:"../learn-async-backing"},r=void 0,l={unversionedId:"learn/learn-async-backing",id:"learn/learn-async-backing",title:"Asynchronous Backing",description:"A brief overview of asynchronous backing, and how it affects Polkadot's scalability.",source:"@site/../docs/learn/learn-async-backing.md",sourceDirName:"learn",slug:"/learn-async-backing",permalink:"/docs/learn-async-backing",draft:!1,editUrl:"https://github.com/w3f/polkadot-wiki/edit/master/docs/learn/learn-async-backing.md",tags:[],version:"current",lastUpdatedBy:"filippoweb3",lastUpdatedAt:1695740349,formattedLastUpdatedAt:"Sep 26, 2023",frontMatter:{id:"learn-async-backing",title:"Asynchronous Backing",sidebar_label:"Asynchronous Backing",description:"A brief overview of asynchronous backing, and how it affects Polkadot's scalability.",keywords:["parachains","backing","parablock","perspective parachains","unincluded segments"],slug:"../learn-async-backing"},sidebar:"docs",previous:{title:"Parathreads",permalink:"/docs/learn-parathreads"},next:{title:"Archive",permalink:"/docs/learn-archive-index"}},d={},p=[{value:"Synchronous Backing",id:"synchronous-backing",level:2},{value:"Sync Backing Mechanics",id:"sync-backing-mechanics",level:3},{value:"Asynchronous Backing",id:"asynchronous-backing",level:2},{value:"Sync vs. Async Backing",id:"sync-vs-async-backing",level:3},{value:"Async Backing Mechanics",id:"async-backing-mechanics",level:3},{value:"Sync Backing as corner case of Async Backing",id:"sync-backing-as-corner-case-of-async-backing",level:3},{value:"Terminology",id:"terminology",level:2},{value:"Candidate Receipt",id:"candidate-receipt",level:3},{value:"Pipelining",id:"pipelining",level:3},{value:"Contextual Execution",id:"contextual-execution",level:3},{value:"Unincluded Segments",id:"unincluded-segments",level:3},{value:"Prospective Parachains",id:"prospective-parachains",level:3},{value:"Learn More",id:"learn-more",level:2}],h={toc:p},k="wrapper";function u(e){var n=e.components,c=(0,i.Z)(e,s);return(0,o.kt)(k,(0,t.Z)({},h,c,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("admonition",{title:"Learn about Parachain Consensus",type:"info"},(0,o.kt)("p",{parentName:"admonition"},"To fully follow the material on this page, it is recommended to be familiar with the primary stages\nof the ",(0,o.kt)("a",{parentName:"p",href:"/docs/learn-parachains-protocol"},"Parachain Protocol"),".")),(0,o.kt)("h2",{id:"synchronous-backing"},"Synchronous Backing"),(0,o.kt)("p",null,"Before diving into asynchronous backing, it is important to understand what synchronous backing is\nand what its main limitations are."),(0,o.kt)("admonition",{title:"What is backing?",type:"info"},(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("strong",{parentName:"p"},"Backing")," refers to the process in which a parablock is verified by a subset of validators who\ndetermine the block\u2019s validity. It is an important step in the validation process for parablocks, as\nit is the first line of defense in ensuring valid state transitions. Validators who back the\nparablock put their stake at risk, and if the block is later found invalid, those validators are\nslashed.")),(0,o.kt)("p",null,"In synchronous backing, parablock generation is tightly coupled to the relay chain's progression on\na one-to-one basis. Every parablock must be generated and backed within a relay-chain block\n(six-second window), and (if successfully backed) it will be included in a relay-chain block (often\nreferred to as the ",(0,o.kt)("strong",{parentName:"p"},"relay parent")," as the parablock anchors itself to it) after an additional six\nseconds. Thus, a parablock can be produced every 12 seconds because a new parablock can be produced\nafter including the previous one. Note ",(0,o.kt)("a",{parentName:"p",href:"#candidate-receipt"},"candidate receipts")," and not the\nparablocks themselves are included in relay parents."),(0,o.kt)("h3",{id:"sync-backing-mechanics"},"Sync Backing Mechanics"),(0,o.kt)("p",null,"The diagram below shows the pipelining table for synchronous backing."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"sync-backing-pipeline",src:a(37063).Z,width:"1920",height:"800"})),(0,o.kt)("p",null,"Backing (B) and inclusion (I) of each parablock happen on different relay chain blocks, and new\nparablocks are generated once the previous parablock has been included.\n",(0,o.kt)("a",{parentName:"p",href:"#contextual-execution"},"Contextual execution")," is driven by the latest included parablock in the most\nrecent relay parent. After 24 seconds, two parablocks, P1 and P2, have been included in the relay\nchain, and P3 has been backed."),(0,o.kt)("p",null,"In synchronous backing we can imagine parablocks on a conveyor belt. The belt is synched with the\nrelay chain: It takes six seconds (one relay block) to generate and back a parablock. It then takes\nanother six seconds to make that parablock available and mark it as included on the relay parent.\nThe full process, from one end of the belt to the other, takes twelve seconds, and cannot be started\nfor parablock N + 1 until it is fully complete for parablock N (no ",(0,o.kt)("a",{parentName:"p",href:"#pipelining"},"pipelining"),")."),(0,o.kt)("p",null,"The diagram below shows parablocks on the conveyor belt, on their way from being generated to being\nbacked and included into the relay parent."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"sync-backing-nofill",src:a(23950).Z,width:"1920",height:"800"}),"\n",(0,o.kt)("img",{alt:"sync-backing-nofill-legend",src:a(18963).Z,width:"1911",height:"480"})),(0,o.kt)("p",null,"Parablock 1 (P1) is included in the latest relay chain parent 1 (R1) after 6 seconds. Once P1 is\nincluded, Parablock 2 (P2) can be generated using the included P1 in R1 as execution context. The\nnext parablock P3 can be generated after P2 is backed into R2 and included into R3, i.e. after 12\nseconds."),(0,o.kt)("p",null,"The diagram below combines the previous diagrams and adds some context about blockspace."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"sync-backing-fill",src:a(82291).Z,width:"1920",height:"800"}),"\n",(0,o.kt)("img",{alt:"sync-backing-fill-legend",src:a(67606).Z,width:"1904",height:"477"})),(0,o.kt)("p",null,"Because P2 is rushing to be backed into R2 in 6 seconds, there are less than 6 seconds (~ 0.5\nseconds) to fill it, since the other 5.5 seconds are needed to get the block backed on chain. In\nthis scenario, P2 is filled up to 70%. After the inclusion of P2 into R3, Parablock 3 (P3) will be\ngenerated, filled to 50%, and backed into R4 in 6 seconds. This shows that, if blockspace demand\ndecreases, collators will always have 0.5 seconds to fill up blocks, leading to blocks that contain\nless and less data."),(0,o.kt)("p",null,"The parablock generation and backing are bound together within a six-second window that limits the\namount of data a collator can add to each parablock. Essentially, a parablock is limited to the\nrequirement of being backed in six seconds, leaving little time for its generation and its\nblockspace to be properly filled."),(0,o.kt)("h2",{id:"asynchronous-backing"},"Asynchronous Backing"),(0,o.kt)("admonition",{title:"Disclaimer: Performance Measurements",type:"warning"},(0,o.kt)("p",{parentName:"admonition"},"Due to asynchronous backing not being fully implemented in a running production network, each\nperformance metric is not thoroughly tested nor guaranteed until proper benchmarking has occurred.")),(0,o.kt)("h3",{id:"sync-vs-async-backing"},"Sync vs. Async Backing"),(0,o.kt)("p",null,"Asynchronous Backing has three overarching goals:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Decrease parachain block (parablock) validation time to ",(0,o.kt)("strong",{parentName:"li"},"6 seconds")," from ",(0,o.kt)("strong",{parentName:"li"},"12 seconds")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Increase usable blockspace"),", allowing more state changes per relay chain block."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Allow parablocks to be re-proposed")," to the network if they are not included successfully on\nthe first attempt.")),(0,o.kt)("p",null,"In synchronous backing, parablock generation relies on the most recent relay-chain block. Each\nparablock must be generated and go through the entire backing process in a single relay block. It\nthen proceeds be made available and marked as included in the next relay block."),(0,o.kt)("p",null,"Asynchronous backing brings the following changes to the parachain protocol:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Parablock generation is now decoupled from the backing process, avoiding the previous 6-second\ndeadline through the backing process. This enables for more involved scaling approaches, such as\ngiving more time for collators to properly use blockspace or increasing block velocity based on\ndemand.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Parachains can generate blocks and have them placed into ",(0,o.kt)("strong",{parentName:"p"},"unincluded segments")," of parablock\nancestors rather than the latest, included relay chain parent."))),(0,o.kt)("h3",{id:"async-backing-mechanics"},"Async Backing Mechanics"),(0,o.kt)("p",null,"Compared to ",(0,o.kt)("a",{parentName:"p",href:"#synchronous-backing-mechanics"},"synchronous backing"),", in asynchronous backing:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Filled blocks are placed in the unincluded segment, a record of yet not included parablocks stored\nlocally on the parachain side."),(0,o.kt)("li",{parentName:"ul"},"Every parablock candidate recorded in the unincluded segment is immediately advertised to\nvalidators to begin the backing process. And the unincluded segment keeps record of all candidates\nin the backing process right up until they are included (in the unincluded segments there\nparablocks that are seconded, backable, and backed)."),(0,o.kt)("li",{parentName:"ul"},"A relay parent (not necessarily the latest block) and the parablock ancestors in the unincluded\nsegment are used as execution context to generate a new parablock and, because the unincluded\nsegment can carry multiple parablocks, parachains can take more time to fill new blocks."),(0,o.kt)("li",{parentName:"ul"},"The conveyor belt can carry multiple parablocks (",(0,o.kt)("a",{parentName:"li",href:"#pipelining"},"pipelining"),"), and a parablock can\nbe in a different stage from another one being built if it abides by the parameters set forth by\nthe asynchronous backing configuration."),(0,o.kt)("li",{parentName:"ul"},"Backing and inclusion events can happen within the same relay chain block (i.e. in 6 seconds)")),(0,o.kt)("p",null,"The diagram below shows the pipelining table for asynchronous backing."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"async-backing-pipeline",src:a(47850).Z,width:"1920",height:"800"})),(0,o.kt)("p",null,"Backing (B) of block N + 1 and inclusion (I) of block N happen on the same relay chain block, and\nnew parablocks are generated before the previous parablock has been included.\n",(0,o.kt)("a",{parentName:"p",href:"#contextual-execution"},"Contextual execution")," is obtained by a relay parent (not necessarily the\nlatest block) and the latest included parablock ancestor in the\n",(0,o.kt)("a",{parentName:"p",href:"#unincluded-segments"},"unincluded segment"),". In 24 seconds, four parablocks, P1 to P4, have been\nincluded in the relay chain, and P5 has been backed."),(0,o.kt)("p",null,"The diagram below shows parablocks on their way from being generated to being backed and included\ninto the relay chain in the context of asynchronous backing."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"async-backing-nofill",src:a(25473).Z,width:"1920",height:"800"}),"\n",(0,o.kt)("img",{alt:"async-backing-nofill-legend",src:a(6395).Z,width:"1908",height:"465"})),(0,o.kt)("p",null,"Parablock 1 (P1) is included, and P2 is backed within R1. In the meantime, the unincluded segment is\nfull and contains P2-4. After P4 is added to the segment and pushed to the relay chain to begin the\nbacking process, P5 can be generated. After 6 seconds, P2 is included (and deleted from the\nsegment), P3 is backed in R2, and P5 has been added to the segment and pushed to the relay chain to\nbe backed. The segment now contains P3-5. Once a parablock has been included, there is no need to\nkeep it in the segment."),(0,o.kt)("p",null,"The diagram below combines the previous diagrams and adds some context about blockspace."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"async-backing-fill",src:a(3671).Z,width:"1920",height:"800"}),"\n",(0,o.kt)("img",{alt:"async-backing-fill-legend",src:a(68265).Z,width:"1909",height:"476"})),(0,o.kt)("p",null,"In synchronous backing collators generated parablocks in 0.5 seconds, since the other 5.5 seconds\nwere needed to get the block backed on chain. In asynchronous backing, because P5 is not rushing to\nbe backed (P3-4 are in the backing process), it can be filled in 2s while P2 is included and P3 is\nbacked in R2. This is possible because the context execution shifted from being the latest included\nparablock in the latest relay parent, to being the latest ancestor in the unincluded segment (i.e.\nP4)."),(0,o.kt)("p",null,"In this scenario, blockspace demand decreases from P3 to P5. In theory, the next block P6 can be\nfilled in >2s seconds while P4 is included and P5 is backed. Collators could make better use of\nblockspace, including more data by increasing block generation time in a period of lower demand.\nNote that even if a collator has >2 seconds to produce a block, the validator will still have less\nthan 6 seconds (~2 seconds) to check it. So, if collators take >2 seconds to generate blocks the\nunincluded segment will shrink (and there will be less parablocks in the pipeline), while if they\ntake <2 seconds the segment will elongate until it reaches the ",(0,o.kt)("inlineCode",{parentName:"p"},"maximum capacity")," (and there will be\nless parablocks in the pipeline)."),(0,o.kt)("p",null,"For example, in case increased blockspace demand after the generation of P6, collators could\ngenerate P7 and P8 within a 6-second window due to the unincluded segment being 2/3 filled (see\nbelow). However, if demand stays high after P8, collators will only be able to generate parablocks\nevery 6 seconds as validators can back parablocks every 6 seconds."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"async-backing-fill-scenario2",src:a(56980).Z,width:"1920",height:"800"})),(0,o.kt)("p",null,"In general, asynchronous backing will allow ",(0,o.kt)("a",{parentName:"p",href:"/docs/learn-parachains-protocol#collators"},"collators")," to\ninclude an estimated ~3-5x more data into parablocks while speeding up parachain block times from 12\nto 6 seconds. Due to the 2x decrease in block time to inclusion and the possibility of building\nblocks in advance to fit more data, Polkadot with asynchronous backing can deliver an estimated\n~6-10x more blockspace to its parachains."),(0,o.kt)("p",null,"This combination of lower latency, higher storage per block, and a logical pipeline spanning\nPolkadot's networking, runtime, and collation aspects will allow for higher, more robust throughput."),(0,o.kt)("h3",{id:"sync-backing-as-corner-case-of-async-backing"},"Sync Backing as corner case of Async Backing"),(0,o.kt)("p",null,"Two parameters of asynchronous backing can be controlled by\n",(0,o.kt)("a",{parentName:"p",href:"/docs/learn-polkadot-opengov"},"Governance"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/paritytech/polkadot-sdk/blob/f204e3264f945c33b4cea18a49f7232c180b07c5/polkadot/primitives/src/vstaging/mod.rs#L54"},(0,o.kt)("inlineCode",{parentName:"a"},"allowed_ancestry_len")),":\nthe number of parachain blocks a collator can produce that are not yet included in the relay\nchain."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/paritytech/polkadot-sdk/blob/f204e3264f945c33b4cea18a49f7232c180b07c5/polkadot/primitives/src/vstaging/mod.rs#L49"},(0,o.kt)("inlineCode",{parentName:"a"},"max_candidate_depth")),":\nthe oldest relay chain parent a parachain block can be built on top of.")),(0,o.kt)("p",null,"Values of zero for both correspond to synchronous backing: ",(0,o.kt)("inlineCode",{parentName:"p"},"allowed_ancestry_len = 0")," means there\ncan be only 1 parablock at a time on the conveyor belt, ",(0,o.kt)("inlineCode",{parentName:"p"},"max_candidate_depth = 0")," means a parachain\nblock can be built only on the latest relay parent for that parachain. Those two parameters will be\ninitially set to 3 and 2, respectively."),(0,o.kt)("h2",{id:"terminology"},"Terminology"),(0,o.kt)("h3",{id:"candidate-receipt"},"Candidate Receipt"),(0,o.kt)("p",null,"Saying that a parablock has been included in a realy chain parent does not mean that the entire\nparablock is in the relay chain block. Instead, ",(0,o.kt)("strong",{parentName:"p"},"candidate receipt")," consisting of the hash of the\nparablock, state roots and ID info is placed on the parent block on the relay chain. The relay chain\ndoes not access the entire state of a parachain but only the values that changed during that block\nand the merkelized hashes of the unchanged values."),(0,o.kt)("h3",{id:"pipelining"},"Pipelining"),(0,o.kt)("p",null,"Asynchronous backing is a feature that introduces\n",(0,o.kt)("a",{parentName:"p",href:"https://www.techtarget.com/whatis/definition/pipelining"},"pipelining")," to the parachain block\n",(0,o.kt)("a",{parentName:"p",href:"/docs/learn-parachains-protocol"},"generation, backing and inclusion"),'. It is analogous to the logical\npipelining of processor instruction in "traditional" architectures, where some instructions may be\nexecuted before others are complete. Instructions may also be executed in parallel, enabling\nmultiple processor parts to work on potentially different instructions simultaneously.'),(0,o.kt)("p",null,"Bundles of state transitions represented as blocks may be processed similarly. In the context of\nPolkadot, pipelining aims to increase the\nthroughput of the entire network by completing the backing and inclusion steps for different blocks\nat the same time. Asynchronous backing does not just allow for pipelining within a single pipe (or\ncore). It lays the foundation for a large number of pipes (~10 cores) to run for the same parachain\nat the same time. In that way we have two distinct new forms of parallel computation: having one\nblock backed and one included simultaneously using one core, and having having ",(0,o.kt)("inlineCode",{parentName:"p"},"n")," blocks backed and\n",(0,o.kt)("inlineCode",{parentName:"p"},"n")," blocks included simultaneously using ",(0,o.kt)("inlineCode",{parentName:"p"},"n")," cores."),(0,o.kt)("h3",{id:"contextual-execution"},"Contextual Execution"),(0,o.kt)("p",null,"Contextual execution refers to the context built by parablock ancestors used by collators to\ngenerate new parablocks. The difference in execution context between synchronous and asynchronous\nbacking is as follows:"),(0,o.kt)("p",null,"In synchronous backing, the entire execution context comes from the latest relay block and most\nrecently included parablock from the same parachain."),(0,o.kt)("p",null,"In asynchronous backing, a baseline execution context is first set up using a parablock's relay\nparent and the most recently included parablock as of that relay parent. The relay parent need not\nbe the most recent relay block. Predecessors of the block under construction live in the\n",(0,o.kt)("a",{parentName:"p",href:"#unincluded-segments"},"unincluded segment")," placed directly in the runtime of parachain collators\n(i.e. off-chain)."),(0,o.kt)("p",null,"Synchronous backing uses execution context entirely pulled from the relay chain. While asynchronous\nbacking augments this with off-chain context from the unincluded segment."),(0,o.kt)("h3",{id:"unincluded-segments"},"Unincluded Segments"),(0,o.kt)("p",null,"The purpose of each unincluded segment is two fold:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Make each parachain aware of when and at what depth it can build blocks that won't be rejected by\nthe relay chain"),(0,o.kt)("li",{parentName:"ul"},"Provide critical context necessary to build parablocks with parent blocks that have yet to be\nincluded. The unincluded segment is all about building parablocks.")),(0,o.kt)("p",null,"Unincluded segments are chains of candidate parablocks that have yet to be included in the relay\nchain, i.e. they can contain parablocks at any stage pre-inclusion. The backing process occurs on\nthe relay chain, whereas unincluded segments live in the runtimes of parachain collators. The core\nfunctionality that asynchronous backing brings is the ability to build on these unincluded segments\nof block ancestors rather than ancestors included in the relay chain state."),(0,o.kt)("p",null,"Compared to synchronous backing, contextual execution shifts from being the parablock ancestors\nincluded in the latest relay parent to being the latest ancestor parablock pushed into the\nunincluded segment. This allows collators to build parablocks earlier, giving them plenty of time to\nfit more transactions and prepare block candidates for backing and inclusion."),(0,o.kt)("h3",{id:"prospective-parachains"},"Prospective Parachains"),(0,o.kt)("p",null,"The purpose of\n",(0,o.kt)("a",{parentName:"p",href:"https://paritytech.github.io/polkadot/book/node/backing/prospective-parachains.html"},"prospective parachains"),"\nis also two fold:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Keep track of parablocks which have been submitted to backers but not yet included. This includes\ntracking the full unincluded ancestry of each parablock, without which it wouldn't be possible to\nverify their legitimacy.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Look up and provide candidates which are children of the most recently included parablock for each\nparachain. These are taken as inputs to the availability process. Prospective parachains is all\nabout tracking, storing, and providing candidates to the availability/inclusion step."))),(0,o.kt)("p",null,"Prospective parachains essentially repeats the work each ",(0,o.kt)("a",{parentName:"p",href:"#unincluded-segments"},"unincluded segment"),"\ndoes in tracking candidates. Validators cannot simply trust the availability or validity of records\nkept on parachains. Prospective parachains is the relay chain's record of all parablock candidates\nundergoing the backing and inclusion process. It is the authoritative gate keeper for parablock\nvalidity. Whereas the unincluded segment is a local record which allows parachains to produce blocks\nwhich comply with the rules prospective parachains later enforces."),(0,o.kt)("p",null,"The unincluded segment lives in the parachain runtime, so it doesn't know or care about forks/other\nparachains. Prospective parachains lives in the relay chain client. So it has to simultaneously keep\ntrack of candidates from all forks of all parachains. It is as if you folded the unincluded segments\nfrom every fork of every parachain into one giant data structure. When you fold unincluded segments\nrepresenting different chain forks together, they create a tree structure. Hence the term\n",(0,o.kt)("a",{parentName:"p",href:"https://paritytech.github.io/polkadot/book/node/backing/prospective-parachains.html#fragment-trees"},(0,o.kt)("strong",{parentName:"a"},"fragment tree")),"."),(0,o.kt)("p",null,"A single unincluded segment tells a collator whether it can build on top of one fork of one\nparachain. Prospective parachains tells a validator whether it should accept blocks built on top of\nany fork from any parachain."),(0,o.kt)("p",null,"A parablock stops being a prospective parablock at the moment when it is included on chain. At that\npoint prospective parachains doesn't have to care about it anymore. Alternatively, a parablock's\nrelay parent can get too old before that parablock is included, in which case prospective parachains\ncan throw away the candidate."),(0,o.kt)("p",null,"The Prospective Parachains subsystem communicates with other subsystems in the validation process,\nsuch as the Backing subsystem, once a candidate block has been seconded."),(0,o.kt)("h2",{id:"learn-more"},"Learn More"),(0,o.kt)("p",null,"This topic is evolving and being implemented at the moment, keep up to date using the following\nresources:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://polkadot.network/blog/polkadot-roadmap-roundup"},"Polkadot Roadmap Roundup")," - Article by\nRob Habermeier, Polkadot founder, details the plans for Polkadot for 2023."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/paritytech/polkadot/issues/3779"},"Asynchronous Backing Spec & Tracking Issue")," -\nThe implementation tracking issue for asynchronous backing"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://paritytech.github.io/polkadot/book/node/backing/prospective-parachains.html"},"Prospective Parachains Subsystem - The Polkadot Parachain Host Implementers' Guide")),(0,o.kt)("li",{parentName:"ul"},"Chapter 6.11. from Polkadot Blockchain Academy (PBA) lecture material:\n",(0,o.kt)("a",{parentName:"li",href:"https://polkadot-blockchain-academy.github.io/pba-book/polkadot/async-backing-shallow/page.html"},"Asynchronous Backing (Shallow)")),(0,o.kt)("li",{parentName:"ul"},"Chapter 6.15. from PBA lecture material:\n",(0,o.kt)("a",{parentName:"li",href:"https://polkadot-blockchain-academy.github.io/pba-book/polkadot/async-backing-deep/page.html"},"Asynchronous Backing (Deep)")),(0,o.kt)("li",{parentName:"ul"},"Polkadot Blog Post -\n",(0,o.kt)("a",{parentName:"li",href:"https://www.polkadot.network/blog/elevating-polkadots-performance-and-scale-with-asynchronous-backing"},"Asynchronous Backing: Elevating Polkadot's Performance and Scale"))))}u.isMDXComponent=!0},68265:(e,n,a)=>{"use strict";a.d(n,{Z:()=>t});const t=a.p+"assets/images/async-backing-fill-legend-9bd27140e99a2bc77a151258eea18739.png"},56980:(e,n,a)=>{"use strict";a.d(n,{Z:()=>t});const t=a.p+"assets/images/async-backing-fill-scenario2-b92d666852b40183dc52d0ae8d7be9c3.png"},3671:(e,n,a)=>{"use strict";a.d(n,{Z:()=>t});const t=a.p+"assets/images/async-backing-fill-25bb83e45faf9ac0c0b2f5274b8bbc57.png"},6395:(e,n,a)=>{"use strict";a.d(n,{Z:()=>t});const t=a.p+"assets/images/async-backing-nofill-legend-e2f2a2e29c1ccb6ea295830f35be9cca.png"},25473:(e,n,a)=>{"use strict";a.d(n,{Z:()=>t});const t=a.p+"assets/images/async-backing-nofill-f0b49a34ac3351ea0bdabdc466bbb522.png"},47850:(e,n,a)=>{"use strict";a.d(n,{Z:()=>t});const t=a.p+"assets/images/async-backing-pipeline-fa4b1281aad6cfa02ad1281fcacf0cbc.png"},67606:(e,n,a)=>{"use strict";a.d(n,{Z:()=>t});const t=a.p+"assets/images/sync-backing-fill-legend-48e1b74a33a89417640c1a8865801333.png"},82291:(e,n,a)=>{"use strict";a.d(n,{Z:()=>t});const t=a.p+"assets/images/sync-backing-fill-dde7976a99c5a6c01466548d34adc0b5.png"},18963:(e,n,a)=>{"use strict";a.d(n,{Z:()=>t});const t=a.p+"assets/images/sync-backing-nofill-legend-481e21e061250332e6dc803e4430f27f.png"},23950:(e,n,a)=>{"use strict";a.d(n,{Z:()=>t});const t=a.p+"assets/images/sync-backing-nofill-60fa601f5e2b0cbcfbd65274dea79e8a.png"},37063:(e,n,a)=>{"use strict";a.d(n,{Z:()=>t});const t=a.p+"assets/images/sync-backing-pipeline-24d064ea00066c81a3379396d84f4b1e.png"},46601:()=>{}}]);