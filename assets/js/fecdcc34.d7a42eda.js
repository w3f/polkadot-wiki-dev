"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8034],{3905:(e,n,r)=>{r.d(n,{Zo:()=>p,kt:()=>b});var t=r(67294);function i(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function o(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function s(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?o(Object(r),!0).forEach((function(n){i(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function a(e,n){if(null==e)return{};var r,t,i=function(e,n){if(null==e)return{};var r,t,i={},o=Object.keys(e);for(t=0;t<o.length;t++)r=o[t],n.indexOf(r)>=0||(i[r]=e[r]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)r=o[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var c=t.createContext({}),l=function(e){var n=t.useContext(c),r=n;return e&&(r="function"==typeof e?e(n):s(s({},n),e)),r},p=function(e){var n=l(e.components);return t.createElement(c.Provider,{value:n},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},d=t.forwardRef((function(e,n){var r=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,p=a(e,["components","mdxType","originalType","parentName"]),u=l(r),d=i,b=u["".concat(c,".").concat(d)]||u[d]||m[d]||o;return r?t.createElement(b,s(s({ref:n},p),{},{components:r})):t.createElement(b,s({ref:n},p))}));function b(e,n){var r=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=r.length,s=new Array(o);s[0]=d;var a={};for(var c in n)hasOwnProperty.call(n,c)&&(a[c]=n[c]);a.originalType=e,a[u]="string"==typeof e?e:i,s[1]=a;for(var l=2;l<o;l++)s[l]=r[l];return t.createElement.apply(null,s)}return t.createElement.apply(null,r)}d.displayName="MDXCreateElement"},26269:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>p,contentTitle:()=>c,default:()=>b,frontMatter:()=>a,metadata:()=>l,toc:()=>u});var t=r(87462),i=r(63366),o=(r(67294),r(3905)),s=["components"],a={id:"learn-xcm-docs-journey-version",title:"XCM Version",sidebar_label:"XCM Version",description:"XCM Version.",keywords:["xcm","cross-consensus messaging","version"],slug:"../journey-version"},c="Version Subscription",l={unversionedId:"learn/xcm/journey/learn-xcm-docs-journey-version",id:"learn/xcm/journey/learn-xcm-docs-journey-version",title:"XCM Version",description:"XCM Version.",source:"@site/../docs/learn/xcm/journey/version.md",sourceDirName:"learn/xcm/journey",slug:"/learn/xcm/journey-version",permalink:"/docs/learn/xcm/journey-version",draft:!1,editUrl:"https://github.com/w3f/polkadot-wiki/edit/master/docs/learn/xcm/journey/version.md",tags:[],version:"current",lastUpdatedBy:"filippoweb3",lastUpdatedAt:1693998917,formattedLastUpdatedAt:"Sep 6, 2023",frontMatter:{id:"learn-xcm-docs-journey-version",title:"XCM Version",sidebar_label:"XCM Version",description:"XCM Version.",keywords:["xcm","cross-consensus messaging","version"],slug:"../journey-version"},sidebar:"docs",previous:{title:"Queries",permalink:"/docs/learn/xcm/journey-queries"},next:{title:"Locks",permalink:"/docs/learn/xcm/journey-locks"}},p={},u=[],m={toc:u},d="wrapper";function b(e){var n=e.components,r=(0,i.Z)(e,s);return(0,o.kt)(d,(0,t.Z)({},m,r,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"version-subscription"},"Version Subscription"),(0,o.kt)("p",null,"XCM is a versioned messaging format. One version may contain more or different instructions than\nanother, so for parties to communicate via XCM, it is important to know which version the other\nparty is using. XCM enables a version subscription model, where parties can subscribe to each other\nto get notified of version updates. XCM has two instructions to enable this:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"SubscribeVersion")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"UnsubscribeVersion"))),(0,o.kt)("p",null,"The version subscription model can differ per XCVM implementation. The ",(0,o.kt)("inlineCode",{parentName:"p"},"xcm-executor")," has a\n",(0,o.kt)("inlineCode",{parentName:"p"},"SubscriptionService")," ",(0,o.kt)("a",{parentName:"p",href:"/docs/learn/xcm/config-deep-dive#subscriptionservice"},"config item"),". Any type\nspecified as the ",(0,o.kt)("inlineCode",{parentName:"p"},"SubscriptionService")," must implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"VersionChangeNotifier")," trait. The XCM\npallet is one such implementor. When the ",(0,o.kt)("inlineCode",{parentName:"p"},"SubscribeVersion")," instruction is sent to a consensus\nsystem that uses the XCM pallet as the ",(0,o.kt)("inlineCode",{parentName:"p"},"SubscriptionService")," in the XCM executor, the system will\nsend back its currently ",(0,o.kt)("inlineCode",{parentName:"p"},"AdvertisedVersion")," and will keep the subscribed location up to date when\nthe version changes. The subscribed location can unsubscribe to version changes by sending the\n",(0,o.kt)("inlineCode",{parentName:"p"},"UnsubscribeVersion")," instruction."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust,noplayground"},"SubscribeVersion {\n    #[codec(compact)]\n    query_id: QueryId,\n    max_response_weight: Weight,\n}\n\nUnsubscribeVersion\n")),(0,o.kt)("p",null,"Check out the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/paritytech/xcm-docs/tree/main/examples"},"example"),"."))}b.isMDXComponent=!0}}]);